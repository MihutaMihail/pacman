//
// General
//

**/// window.innerWidth / windows.addEventListener \\\**

You'll see that in the code, there are no "window." because the browser is smart enough to understand what we're trying to do so there is no need to
write "window.". 
This means that we can tidy our code a little more


**/// importing / exporting values \\\**

It seems that getting the canvas elements js file will take priority which means that any code in that file that you don't want to be executed, will be executed because 
this file will have priority over any other files. In addition, when exporting a value, it will export a reference to the actual value. This means that if the value is
modified after exporting it, it will still have the modified value

--------------------------------------------------------------------------------------------------------------------------------------------

//
// Keyboard Input
//

**/// addEventListener('keydown', ({key})) => ... \\\**

The reason why we're using {key} is because when we press down a key, we can collect all data that comes within the object "event"
By using "{key}" we can extract the only element that we need, in this case it's "key" inside the object "event"


**/// player.velocity.x = 0;  \\\**
**/// player.velocity.y = -5; \\\**

When you have velocity x & y to a certain value (not 0), it will move diagonally. However, if you were to set the other value (x or y) to 0 beforehand,
it means that it will only move up, down, left or right. It will not move diagonally anymore

--------------------------------------------------------------------------------------------------------------------------------------------

//
// Boundary Draw
//

**/// map.forEach(row, i)... \\\**

This method will go through every element in an array, we can call it whatever we want (ie row)
If you want to get the index of the element in the array, all you need to do is to put a comma and write a variable name
It will automatically put the index value into the second variable

--------------------------------------------------------------------------------------------------------------------------------------------

//
// Player Class
//

**/// draw() --> beginPath() \\\**

The beginPath() method allows us to start a path so that we can draw our own object (lines, arc, curves) which we need for our player

**/// c.save() && c.restore() \\\**

Using the rotate method that we've used, we need to first wrap our object that we want to rotate if now it will rotate the whole canvas
c.rotate() && c.translate() are global functions meaning that they will affect the whole canvas

**/// this.radians \\\**

A full circle is Math.PI * 2, so adding / substraction 0.75 will take away a portion a the circle

--------------------------------------------------------------------------------------------------------------------------------------------

//
// Animate
//

**/// circle: {...player, velocity: {x:0, y-3}} \\\**

This code copies the object "player" into the object "circle". However, we now have actual object with all its properties 
but we can freely modify some properties like "velocity"


**/// if (Math.hypot(pellet.position.x - player.position.x, pellet.position.y - player.position.y) < pellet.radius . player.radius) \\\**

This code is useful for calculating distances between two points in 2d or 3d. In this example, we want to calculate the distance between our player and the pellet.
However this code will only calculate the distance between the center of these two points. The 2nd part "< pellet.radius..." will calculate the distance between these
two points using their radius to know if they're touching.

**/// for (let i = pellets.length - 1; 0 < i; i--) \\\**

Everytime we splice the array of pellets to remove the pellet that ther user has touched, the pellets inside the array will shift position and will flash for a split second.
To remove that, we'll need to run through the array of pellets backwards

**/// if (JSON.stringify(collisions) !== JSON.stringify(ghost.prevCollisions)) \\\**

To properly test if two arrays are the same, we can use "JSON.stringify()" to tranform the arrays intro strings so that they can be compared

